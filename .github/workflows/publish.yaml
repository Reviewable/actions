name: Reusable NPM publish

on:
  workflow_call:
    inputs:
      directory:
        type: string
        default: .

permissions:
  id-token: write  # Required for OIDC
  contents: read

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Detect package manager
        id: detect-pm
        working-directory: ${{ inputs.directory }}
        run: |
          if [ -f yarn.lock ]; then
            echo "pm=yarn" >> "$GITHUB_OUTPUT"
          else
            echo "pm=npm" >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve Node LTS version
        id: resolve
        run: |
          v=$(curl -s https://nodejs.org/dist/index.json | jq -r '[.[] | select(.lts != false)][0].version')
          echo "version=$v" >> "$GITHUB_OUTPUT"

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ steps.resolve.outputs.version }}
          registry-url: 'https://registry.npmjs.org'
          cache: ${{ steps.detect-pm.outputs.pm }}

      - name: Update npm
        run: npm install -g npm@latest

      - run: ${{ steps.detect-pm.outputs.pm }} install
        working-directory: ${{ inputs.directory }}
      - run: if jq -e '.scripts.build // empty' package.json >/dev/null; then ${{ steps.detect-pm.outputs.pm }} run build; fi
        working-directory: ${{ inputs.directory }}
      - run: if jq -e '.scripts.lint  // empty' package.json >/dev/null; then ${{ steps.detect-pm.outputs.pm }} run lint; fi
        working-directory: ${{ inputs.directory }}
      - run: if jq -e '.scripts.test  // empty' package.json >/dev/null; then ${{ steps.detect-pm.outputs.pm }} run test; fi
        working-directory: ${{ inputs.directory }}

      - name: Verify tarball matches published version (if any)
        id: decide
        working-directory: ${{ inputs.directory }}
        run: |
          set -euo pipefail

          decision=$(node << 'EOF'
          const { execSync } = require('node:child_process');
          const fs = require('node:fs');

          function sh(cmd) {
            return execSync(cmd, {encoding: 'utf8', stdio: ['ignore', 'pipe', 'pipe']}).trim();
          }

          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const name = pkg.name;
          const version = pkg.version;

          let published;
          try {
            const json = sh(\`npm view \${name}@\${version} --json\`);
            published = JSON.parse(json);
          } catch (e) {
            const stderr = String(e.stderr || '');
            // 404: version does not exist yet → publish
            if (stderr.includes('E404') || stderr.includes('404 Not Found')) {
              console.error(\`[decide] \${name}@\${version} not found in registry; will publish.\`);
              console.log('publish');
              process.exit(0);
            }
            console.error('[decide] npm view failed unexpectedly:', stderr || e);
            process.exit(1);
          }

          const integrity = published.dist && published.dist.integrity;
          if (!integrity) {
            console.error(\`[decide] \${name}@\${version} exists but has no dist.integrity; refusing.\`);
            process.exit(1);
          }

          // Build local tarball
          console.error('[decide] Building local tarball with npm pack…');
          sh('npm pack --silent');

          const file = fs.readdirSync('.').find(f => f.endsWith('.tgz'));
          if (!file) {
            console.error('[decide] No .tgz file produced by npm pack.');
            process.exit(1);
          }

          console.error(\`[decide] Computing integrity for \${file}…\`);
          const localIntegrity = sh(\`npx --yes ssri generate "\${file}"\`);

          if (localIntegrity === integrity) {
            console.error(\`[decide] Identical tarball already published for \${name}@\${version}; skipping.\`);
            console.log('skip');
            process.exit(0);
          }

          console.error(\`[decide] \${name}@\${version} already exists but tarball differs; refusing.\`);
          process.exit(1);
          EOF
          )

          echo "decision=${decision}" >> "$GITHUB_OUTPUT"

      - run: npm publish
        if: steps.decide.outputs.decision == 'publish'
        working-directory: ${{ inputs.directory }}
